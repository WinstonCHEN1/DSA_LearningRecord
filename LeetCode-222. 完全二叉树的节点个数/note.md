# 完全二叉树的节点个数

## 题目描述
给你一棵 完全二叉树 的根节点 `root` ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 `1~ 2^h` 个节点。

- 示例 1：

输入：root = [1,2,3,4,5,6]
输出：6

- 示例 2：

输入：root = []
输出：0

- 示例 3：

输入：root = [1]
输出：1

## 标签

二叉树 完全二叉树 递归

## 原文链接

* [https://leetcode.cn/problems/count-complete-tree-nodes/](https://leetcode.cn/problems/count-complete-tree-nodes/)

## 思路

这里留一个坑，这题有好几种解法。

我的这个解法就是朴实无华的递归，直接看代码就知道，两行完事，还是挺妙的。

但是这题可以用完全二叉树的性质解，也可以再加上二分查找，思路贴在下面。

### 纯完全二叉树

这是一棵完全二叉树：除最后一层外，其余层全部铺满；且最后一层向左停靠

如果根节点的左子树深度等于右子树深度，则说明 左子树为满二叉树

如果根节点的左子树深度大于右子树深度，则说明 右子树为满二叉树

如果知道子树是满二叉树，那么就可以轻松得到该子树的节点数目：(1<<depth) - 1; // depth为子树的深度；为了加快幂的运算速度，可以使用移位操作符

接着我们只需要接着对另一子树递归即可

时间复杂度为 O(logn∗logn)，空间复杂度为 O(1)【不考虑递归调用栈】

### 完全二叉树性质+二分查找

根据完全二叉树的性质，我们可以清楚的知道：总节点数 = 倒数第二层以上的节点数 + 最后一层的节点数

除最后一层外，这棵树为满二叉树，节点数为：2^depth_prev - 1，depth_prev为倒数第二层树的深度

最后一层的节点数的范围是 [1, 2^depth_prev]；并且依次靠左排列

所以现在的问题就转换为判断最后一层节点数

先不说怎么判断一个节点是否存在，假设这个方法为 is_exist()，我们先了解一下二分法如何使用：

最后一层节点情况： 1 代表非空节点，0 代表空节点

所以现在的问题就可以简单的看成最后一个 1 的索引位置，怎么用二分法就不用我说了。

接下来是如何判断最后一层某个节点是否存在，也就是 is_exist()函数：

给定最后一层某节点的位置索引 index，将他和分界线比大小，就可以判断该节点在左子树还是右子树，例如：现在查找 6 这个节点，索引为 3，大于分界线 2，所以 6 在右子树；对右子树重复操作即可，剩下的工作就交给迭代了~~~
